---
layout: post
title: "汇编笔记05" 
tag: Assembly
---

- CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的**低位字节**存放在**低地址**单元中，**高位字节**存放在**高地址**单元中。

- 字单元：即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。

- N地址单元：将起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元。

- CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。

- 8086CPU中有一个DS寄存器，通常用来存放要访问数据的***段地址***，比如我们要读取10000H单元的内容，可以用如下的程序段进行：

```assembly
  mov bx,1000H
  mov ds,bx
  mov al,[0]
```

上面的3条指令将10000H（1000：0）中的数据读到`al`中。
***

- 前面使用mov指令，可完成两种传送：
  1. 将数据直接送入寄存器中，如： `mov bx,1000H`
  2. 将一个寄存器中的内容送入另一个寄存器，如：`mov ds,bx`

- 也可以使用mov指令将一个内存单元中的内容送入一个寄存器中。
- “[...]”表示一个内存单元，“[0]”中的0表示内存单元的偏移地址，执行指令时，8086CPU自动取`ds`中的数据为内存单元的段地址。

- 8086CPU不支持将数据直接送入段寄存器的操作，如：`mov ds,1000H`是**错误**的。所以只好用一个寄存器来进行中转，即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。

- 因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。比如：

```assembly
mov bx,1000H
mov ds,bx
mov ax,[0]    ;1000:0处的字型数据送入ax
mov [0],cx    ;cx中的16位数据传送到1000:0处
```

- P51-P53

- `push ax`表示将寄存器ax中的数据送入栈中，`pop ax`表示从栈顶取出数据送入ax。
- 8086CPU的入栈和出栈操作都是以***字***为单位进行的。
- 8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。
- ***任意时刻，SS:SP指向栈顶元素***
- 栈顶的位置是在高地址。
- `push ax` 的执行，由以下两步执行：
  1. SP=SP-2,SS:SP指向当前栈顶**前面**单元，以当前栈顶前面的单元为新的栈顶。
  2. 将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。

- `pop ax` 的执行，由以下两步执行：
  1. 将SS:SP指向的内存单元处的数据送入ax。
  2. SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

- 栈顶超界问题（P61）

- push和pop指令的格式可以是如下形式：

```assembly
push 寄存器
push 段寄存器
push 内存单元
```

- 栈段（P68）

- 实验2（P71）

---

转载请注明：[guanjianhe的博客](https://guanjianhe.github.io/) » [汇编笔记05](https://guanjianhe.github.io/2020/02/assembly05/)